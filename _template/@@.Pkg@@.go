@@ if eq .Type "inspect" -@@
package @@.Pkg@@

import (
	"go/ast"

	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/passes/inspect"
	"golang.org/x/tools/go/ast/inspector"
)

const doc = "@@.Pkg@@ is ..."

// Analyzer is ...
var Analyzer = &analysis.Analyzer{
	Name: "@@.Pkg@@",
	Doc:  doc,
	Run:  run,
	Requires: []*analysis.Analyzer{
		inspect.Analyzer,
	},
}

func run(pass *analysis.Pass) (interface{}, error) {
	inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

	nodeFilter := []ast.Node{
		(*ast.Ident)(nil),
	}

	inspect.Preorder(nodeFilter, func(n ast.Node) {
		switch n := n.(type) {
		case *ast.Ident:
			if n.Name == "gopher" {
				pass.Reportf(n.Pos(), "identifier is gopher")
			}
		}
	})

	return nil, nil
}
@@ end -@@
@@ if eq .Type "ssa" -@@
package @@.Pkg@@

import (
	"fmt"

	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/passes/buildssa"
)

const doc = "@@.Pkg@@ is ..."

// Analyzer is ...
var Analyzer = &analysis.Analyzer{
	Name: "@@.Pkg@@",
	Doc:  doc,
	Run:  run,
	Requires: []*analysis.Analyzer{
		buildssa.Analyzer,
	},
}

func run(pass *analysis.Pass) (interface{}, error) {
	s := pass.ResultOf[buildssa.Analyzer].(*buildssa.SSA)
	for _, f := range s.SrcFuncs {
		fmt.Println(f)
		for _, b := range f.Blocks {
			fmt.Printf("\tBlock %d\n", b.Index)
			for _, instr := range b.Instrs {
				fmt.Printf("\t\t%[1]T\t%[1]v(%[1]p)\n", instr)
				for _, v := range instr.Operands(nil) {
					if v != nil {
						fmt.Printf("\t\t\t%[1]T\t%[1]v(%[1]p)\n", *v)
					}
               			}
			}
		}
	}
	return nil, nil
}
@@ end -@@
@@ if eq .Type "codegen" -@@
package @@.Pkg@@

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"os"

	"github.com/gostaticanalysis/analysisutil"
	"github.com/gostaticanalysis/codegen"
	"github.com/gostaticanalysis/knife"
)

const doc = "@@.Pkg@@ is ..."

var (
	flagOutput string
)

func init() {
	Generator.Flags.StringVar(&flagOutput, "o", "", "output file name")
}

var Generator = &codegen.Generator{
	Name: "@@.Pkg@@",
	Doc:  doc,
	Run:  run,
}

func run(pass *codegen.Pass) error {
	ifaces := map[string]*knife.Interface{}

	s := pass.Pkg.Scope()
	for _, name := range s.Names() {
		obj := s.Lookup(name)
		if !obj.Exported() {
			continue
		}
		iface, _ := analysisutil.Under(obj.Type()).(*types.Interface)
		if iface != nil {
			ifaces[name] = knife.NewInterface(iface)
		}
	}

	td := &knife.TempalteData{
		Fset:      pass.Fset,
		Files:     pass.Files,
		TypesInfo: pass.TypesInfo,
		Pkg:       pass.Pkg,
	}
	t, err := knife.NewTemplate(td).Parse(tmpl)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, ifaces); err != nil {
		return err
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	if flagOutput == "" {
		pass.Print(string(src))
		return nil
	}

	f, err := os.Create(flagOutput)
	if err != nil {
		return err
	}

	fmt.Fprint(f, string(src))

	if err := f.Close(); err != nil {
		return err
	}

	return nil
}

var tmpl = `// Code generated by @@.Pkg@@; DO NOT EDIT.
package {{(pkg).Name}}
{{range $tn, $t := .}}
type Mock{{$tn}} struct {
{{- range $n, $f := $t.Methods}}
        {{$n}}Func {{$f.Signature}}
{{- end}}
}
{{range $n, $f := $t.Methods}}
func (m *Mock{{$tn}}) {{$n}}({{range $f.Signature.Params}}
	{{- if (and $f.Signature.Variadic (eq . (last $f.Signature.Params)))}}
        	{{- .Name}} ...{{(slice .Type).Elem}},
	{{- else}}
        	{{- .Name}} {{.Type}},
	{{- end}}
{{- end}}) ({{range $f.Signature.Results}}
        {{- .Name}} {{.Type}},
{{- end}}) {
        {{if $f.Signature.Results}}return {{end}}m.{{$n}}Func({{range $f.Signature.Params}}
		{{- if (and $f.Signature.Variadic (eq . (last $f.Signature.Params)))}}
        		{{- .Name}}...,
		{{- else}}
        		{{- .Name}},
		{{- end}}
        {{- end}})
}
{{end}}
{{end}}
`
@@ end -@@
